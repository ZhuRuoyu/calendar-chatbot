# -*- coding: utf-8 -*-
"""Custom Named Entity Recognition (NER).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q7jXzZH8AT-Y1Vn71syIHKjkwEvAhtMF

# Extract

summary, start_time, end_time, date, location, event_id,

date = False, event_id = False, summary=False, start_time=False, end_time=False, location=False

## event_id

https://stackoverflow.com/questions/32755413/how-can-i-find-the-event-id-of-my-google-calendar-event

https://www.base64decode.org/

4htgpmm1hmak744r0kbkdcodar eugu9kan1ddi1pmi6sk3ib5Â¨6g@g

# spaCy v3
tutorial: https://levelup.gitconnected.com/auto-detect-anything-with-custom-named-entity-recognition-ner-c89d6562e8e9

using spaCy to annotate the text 1st,

TOOLS:spacy prodigy software annotation NER (charged)
"""

# library imports
import pandas as pd
import spacy
from spacy import displacy
from spacy.tokens import DocBin
import json
from datetime import datetime
from tqdm import tqdm
import re

#!jupyter-labextension install jupyterlab-prodigy

# key words [ date,summary, start_time, end_time, location,  event_id, ]

collective_dict = {'TRAINING_DATA': []}

def structure_training_data(text, kw_date, kw_summary, kw_start_time, kw_end_time, kw_location, kw_event_id):
    results = []
    entities = []

    for kw_list in [kw_date, kw_summary, kw_start_time, kw_end_time, kw_location, kw_event_id]:
      #kw_list = date list / summary list ...

      # search for instances of keywords within the text (ignoring letter case)

      entity_name = kw_list['name']

      for kw in tqdm(kw_list['list']):

          search = re.finditer(kw, str(text), flags=re.IGNORECASE)

          # store the start/end character positions
          all_instances = [[m.start(),m.end()] for m in search]

          # if the callable_iterator found matches, create an 'entities' list
          if len(all_instances)>0:
              for i in all_instances:
                  start = i[0]
                  end = i[1]
                  entities.append((start, end, entity_name))

          # alert when no matches are found given the user inputs
          else:
              print("No pattern matches found. Keyword:", kw)






    # add any found entities into a JSON format within collective_dict
    if len(entities)>0:
        results = [text, {"entities": entities}]
        collective_dict['TRAINING_DATA'].append(results)
        return

#input_sentences = [

text5 = "Could you please schedule a Google Calendar event for me? The event details are as follows: \n Schedule a meeting on July 23, 2024, starting at 10:00 AM and ending at 11:00 AM. \nLet's meet at Conference Room 101. The event ID for this meeting is 4htgpmm1hmak744r0kbkdcodar.",

text6 = "Schedule a video conference on August 5, 2023, from 2:00 PM to 3:00 PM. \n The meeting will take place online using Zoom. \n The event ID is s5gpmm1h3v77l84r0kz9dcoda4.",

text7 = "Set up a lunch meeting on September 10, 2023, starting at 12:30 PM and ending at 1:30 PM.\n We will dine at the restaurant 'La Bella Italia' downtown. \n The event ID is b1gpmm1hc08c99rr8k6idcodb7.",

text8 = "Plan a team training session on October 20, 2023, from 9:00 AM to 12:00 PM. \n The session will be held in the Training Room, Building B. The event ID is n9gpmm1h5zme375r0kcidcoda2." ,

text9 = "Please schedule a conference call on November 15, 2023, from 3:00 PM for approximately 1 hour. \n We will discuss the new project proposal. The call will take place online, and the event ID is x3gpmm1h93a617rr0kcudcoday.",

text10 = "Schedule a client meeting on December 10, 2023, starting at 10:30 AM. \n The meeting is expected to last for about 2 hours. We will meet at their office location. The event ID is z0gpmm1huzxw75ar0kiedcoda3.",
#]

kw_date = {"name": 'DATE',"list": ['July 23, 2024']}
kw_summary = {"name": 'SUMMARY',"list": ['a meeting']}
kw_start_time = {"name": 'START_TIME',"list": ['10:00 AM']}
kw_end_time = {"name": 'END_TIME',"list": ['11:00 AM']}
kw_location = {"name": 'LOCATION',"list": ['Conference Room 101']}
kw_event_id = {"name": 'EVENT_ID',"list": ['4htgpmm1hmak744r0kbkdcodar']}



structure_training_data(text5, kw_date,kw_summary,kw_start_time,kw_end_time, kw_location, kw_event_id)

# TRAINING



structure_training_data(
    text6,
     {"name": 'DATE',
      "list": ['August 5, 2023']},

       {"name": 'SUMMARY',
        "list": ['a video conference']},

    {"name": 'START_TIME',
        "list": ['2:00 PM']},

    {"name": 'END_TIME',
        "list": ['3:00 PM']},

    {"name": 'LOCATION',
        "list": ['online using Zoom']},

    {"name": 'EVENT_ID',
        "list": ['s5gpmm1h3v77l84r0kz9dcoda4']},

    )

structure_training_data(
    text7,
     {"name": 'DATE',
      "list": ['September 10, 2023']},

       {"name": 'SUMMARY',
        "list": ['a lunch meeting']},

    {"name": 'START_TIME',
        "list": ['12:30 PM']},

    {"name": 'END_TIME',
        "list": ['1:30 PM']},

    {"name": 'LOCATION',
        "list": ["at the restaurant 'La Bella Italia' downtown"]},

    {"name": 'EVENT_ID',
        "list": ['b1gpmm1hc08c99rr8k6idcodb7']},

    )

structure_training_data(
    text8,
     {"name": 'DATE',
      "list": ['October 20, 2023']},

       {"name": 'SUMMARY',
        "list": ['a team training session']},

    {"name": 'START_TIME',
        "list": ['9:00 AM']},

    {"name": 'END_TIME',
        "list": ['12:00 PM']},

    {"name": 'LOCATION',
        "list": ['Training Room, Building B']},

    {"name": 'EVENT_ID',
        "list": ['n9gpmm1h5zme375r0kcidcoda2']},

    )



structure_training_data(
    text9,
     {"name": 'DATE',
      "list": ['November 15, 2023']},

       {"name": 'SUMMARY',
        "list": ['a conference call', 'discuss the new project proposal']},

    {"name": 'START_TIME',
        "list": ['3:00 PM']},

    {"name": 'END_TIME',
        "list": ['approximately 1 hour']},

    {"name": 'LOCATION',
        "list": ['online']},

    {"name": 'EVENT_ID',
        "list": ['x3gpmm1h93a617rr0kcudcoday']},

    )



structure_training_data(
    text10,
     {"name": 'DATE',
      "list": ['December 10, 2023']},

       {"name": 'SUMMARY',
        "list": ['a client meeting']},

    {"name": 'START_TIME',
        "list": ['10:30 AM']},

    {"name": 'END_TIME',
        "list": ['last for about 2 hours']},

    {"name": 'LOCATION',
        "list": ['their office locatio']},

    {"name": 'EVENT_ID',
        "list": ['z0gpmm1huzxw75ar0kiedcoda3']},

    )

# text1 = "BigTime Care has a broad array of service offerings for Philadelphia-area clientele. \
# For 50 years, we have specialized in landscaping and lawn mowing. \
# We also provide seasonal snow removal services for local commercial and residential properties. \
# Call any time to schedule a consultation!"

# text2 = "Scrub-O Cleaning connects independent professionals with customers. \
# We offer the full range of customizable cleaning services that you may need now and in \
# the future, and our team is ready to begin working for you today! We offer quality maid \
# services and housekeeping across the San Francisco Bay Area."

# text3 = "Locally owned and operated, Trust Roofing has the best roofing services in \
# Philadelphia and the surrounding areas. Whatever the season, you can count on us to provide \
# you with the best possible roof repair.\ We will work with any given roof replacement material, \
# including asphalt shingles and metal roofs. Siding replacement services are also available."

# text4 = "Based in Pittsburgh PA, Tammy's Branch Cuts is a family owned and managed smalled \
# businesses founded in 1994. We specialize in full-service landscape design, including \
# tree removal, lawn care to protect your existing plants, and comprehensive hardscaping for \
# patios, walkways, and outdoor living spaces. Contact us today!"

# # TRAINING

# #{ "name": 'DATE', "list": ['landscaping', 'lawn mowing', 'snow removal']}
# #{ "name": 'SUMMARY', "list": ['any time']}


# structure_training_data(text1, {"name": 'DATE',
#                                 "list": ['landscaping', 'lawn mowing', 'snow removal']},
#                                  {"name": 'SUMMARY',
#                                   "list": ['any time']})


# structure_training_data(text2, { "name": 'DATE', "list": ['cleaning services', 'maid services', 'housekeeping']}, { "name": 'SUMMARY', "list": ['today']})

# structure_training_data(text3, { "name": 'DATE', "list": ['roofing', 'roof repair', 'siding replacement']}, { "name": 'SUMMARY', "list": ['whatever season']})

# structure_training_data(text4, { "name": 'DATE', "list": ['landscape design', 'tree removal', 'lawn care', 'hardscaping']}, { "name": 'SUMMARY', "list": ['1994', 'today']})





# structure_training_data(text2, ['cleaning services', 'maid services', 'housekeeping'], ['today'])
# structure_training_data(text3, ['roofing', 'roof repair', 'siding replacement'], ['whatever season'])
# structure_training_data(text4, ['landscape design', 'tree removal', 'lawn care', 'hardscaping'], ['1994', 'today'])

collective_dict['TRAINING_DATA']

collective_dict

"""# save training data  in .spacy"""

# define our training data to TRAIN_DATA
TRAIN_DATA = collective_dict['TRAINING_DATA']

# create a blank model
nlp = spacy.blank('en')

def create_training(TRAIN_DATA):
    db = DocBin()
    for text, annot in tqdm(TRAIN_DATA):
        doc = nlp.make_doc(str(text))
        ents = []

        # create span objects
        for start, end, label in annot["entities"]:
            span = doc.char_span(start, end, label=label, alignment_mode="contract")

            # skip if the character indices do not map to a valid span
            if span is None:
                print("Skipping entity.")
            else:
                ents.append(span)
                # handle erroneous entity annotations by removing them
                try:
                    doc.ents = ents
                except:
                    # print("BAD SPAN:", span, "\n")
                    ents.pop()
        doc.ents = ents

        # pack Doc objects into DocBin
        db.add(doc)
    return db

TRAIN_DATA_DOC = create_training(TRAIN_DATA)

# Export results (here I add it to a TRAIN_DATA folder within the directory)
TRAIN_DATA_DOC.to_disk("TRAIN_DATA.spacy")



"""# train the model"""

!pip install -U pip setuptools wheel
!pip install -U spacy
#!python -m spacy download en_core_web_sm
!python -m spacy download en_core_web_lg

!python -m spacy init fill-config base_config.cfg config.cfg

#!python -m spacy train config.cfg --output ./output drive/MyDrive/capstone-nlp/
!python -m spacy train config.cfg --output ./capstone_ner_output

"""# TEST the custom tagging
after running command line for spacy on local terminal (with cpu)

### MOUNT GOOGLE DRIVE TO UPLOAD THE MODEL
"""

# load the trained model

#model_path = 'drive/MyDrive/capstone_ner_output'
model_path = '/capstone_ner_output'
spacy.load(model_path + "/model-best")

model_test1 = "Schedule a training workshop on February 20, 2024, from 9:00 AM to 12:00 PM. The workshop will take place at the Training Room, Building C. The event ID is w2gpmm1h0sd98vjr0khndcoda6."



#model_test2 = "Plan a team brainstorming session on April 5, 2024, starting at 2:30 PM. The session will last approximately 2 hours and will be held in the Innovation Lab. The event ID is m5gpmm1huhjk27rr0kntdcoda1."


# pass our test instance into the trained pipeline
doc = nlp_output(model_test1)

# customize the label colors
#colors = {"DATE": "linear-gradient(90deg, #E1D436, #F59710)"}
#options = {"ents": ["DATE"], "colors": colors}

# visualize the identified entities
#displacy.render(doc, style="ent", options=options)

# print out the identified entities
for ent in doc.ents:
    print(ent.text, ent.label_)
    #if ent.label_ == "DATE":
    #    print(ent.text, ent.label_)

